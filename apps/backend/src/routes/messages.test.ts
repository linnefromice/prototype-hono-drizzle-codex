import { describe, expect, it, beforeAll, afterAll, beforeEach } from 'vitest'
import app from '../index'
import { expectValidZodSchema, expectValidZodSchemaArray } from '../__tests__/helpers/zodValidation'
import { expectMatchesSnapshot } from '../__tests__/helpers/snapshotHelpers'
import {
  deleteMessagesIdReactionsEmojiResponse,
  deleteMessagesIdBookmarksResponse,
  getUsersUserIdBookmarksResponseItem,
  getMessagesIdReactionsResponse,
} from 'openapi'
import zod from 'zod'
import { db, closeDbConnection, sqlite } from '../infrastructure/db/client'
import { users, conversations, participants, messages as messagesTable, reactions as reactionsTable, conversationReads, messageBookmarks as messageBookmarksTable, authUser, authSession } from '../infrastructure/db/schema'
import { setupTestDatabase } from '../__tests__/helpers/dbSetup'
import { createAuthenticatedUser, createAuthHeaders } from '../__tests__/helpers/authHelper'

// Manual schema for POST /messages/:id/bookmarks response
// (Not generated by Orval as the OpenAPI spec may be incomplete)
const postMessagesIdBookmarksResponse = zod.object({
  status: zod.enum(['bookmarked']),
  bookmark: zod.object({
    id: zod.string().uuid(),
    messageId: zod.string().uuid(),
    userId: zod.string().uuid(),
    createdAt: zod.string().datetime({}),
  }),
})

describe('Messages API', () => {
  beforeAll(async () => {
    await setupTestDatabase()
  })

  beforeEach(async () => {
    // Clean up database between tests (foreign key order matters)
    await db.delete(messageBookmarksTable)
    await db.delete(reactionsTable)
    await db.delete(conversationReads)
    await db.delete(messagesTable)
    await db.delete(participants)
    await db.delete(conversations)
    await db.delete(authSession)
    await db.delete(users)
    await db.delete(authUser)
  })

  afterAll(async () => {
    await closeDbConnection()
  })

  // Helper function to create test users (dev-only endpoint)
  async function createUser(name: string, idAlias: string) {
    const response = await app.request('/users', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ name, idAlias }),
    })
    return response.json()
  }

  // Helper function to create authenticated user with chat user
  async function createAuthUserWithChatUser(username: string, email: string) {
    const { user, sessionToken } = await createAuthenticatedUser(username, email)

    // Create a chat user linked to the auth user via authUserId
    const [chatUser] = await db.insert(users).values({
      authUserId: user.id, // Link to auth user
      name: username,
      idAlias: username,
      createdAt: new Date().toISOString(),
    }).returning()

    return { authUser: user, chatUser, sessionToken, headers: createAuthHeaders(sessionToken) }
  }

  // Helper function to create a conversation
  async function createConversation(participantIds: string[], headers: Record<string, string>, name?: string) {
    const response = await app.request('/conversations', {
      method: 'POST',
      headers: { ...headers, 'Content-Type': 'application/json' },
      body: JSON.stringify({
        type: participantIds.length === 2 ? 'direct' : 'group',
        name: participantIds.length > 2 ? name || 'Test Group' : undefined,
        participantIds,
      }),
    })
    return response.json()
  }

  // Helper function to send a message
  async function sendMessage(conversationId: string, headers: Record<string, string>, text: string) {
    const response = await app.request(`/conversations/${conversationId}/messages`, {
      method: 'POST',
      headers: { ...headers, 'Content-Type': 'application/json' },
      body: JSON.stringify({
        text,
      }),
    })
    return response.json()
  }

  describe('POST /messages/:id/reactions', () => {
    it('adds a reaction to a message', async () => {
      const { chatUser: user1, headers: user1Headers } = await createAuthUserWithChatUser('user1', 'user1@test.com')
      const user2 = await createUser('User 2', 'user2')

      // Create conversation and message
      const conversation = await createConversation([user1.id, user2.id], user1Headers)
      const message = await sendMessage(conversation.id, user1Headers, 'Hello!')

      // Add reaction (authenticated user1 is reacting, not user2)
      const response = await app.request(`/messages/${message.id}/reactions`, {
        method: 'POST',
        headers: { ...user1Headers, 'Content-Type': 'application/json' },
        body: JSON.stringify({
          emoji: 'ðŸ‘',
        }),
      })

      expect(response.status).toBe(201)

      const reaction = await response.json()

      // Zod schema validation
      expectValidZodSchema(deleteMessagesIdReactionsEmojiResponse, reaction, 'reaction')

      // Snapshot testing - captures complete reaction structure
      expectMatchesSnapshot(reaction, 'POST /messages/:id/reactions - add reaction')

      // Business logic assertions
      expect(reaction.messageId).toBe(message.id)
      expect(reaction.userId).toBe(user1.id) // Authenticated user (user1) added the reaction
      expect(reaction.emoji).toBe('ðŸ‘')
    })

    it('allows multiple users to react with the same emoji', async () => {
      const { chatUser: user1, headers: user1Headers } = await createAuthUserWithChatUser('user1', 'user1@test.com')
      const { chatUser: user2, headers: user2Headers } = await createAuthUserWithChatUser('user2', 'user2@test.com')
      const user3 = await createUser('User 3', 'user3')

      const conversation = await createConversation([user1.id, user2.id, user3.id], user1Headers)
      const message = await sendMessage(conversation.id, user1Headers, 'Great news!')

      // User 1 reacts
      const response1 = await app.request(`/messages/${message.id}/reactions`, {
        method: 'POST',
        headers: { ...user1Headers, 'Content-Type': 'application/json' },
        body: JSON.stringify({
          emoji: 'ðŸŽ‰',
        }),
      })

      // User 2 reacts with same emoji
      const response2 = await app.request(`/messages/${message.id}/reactions`, {
        method: 'POST',
        headers: { ...user2Headers, 'Content-Type': 'application/json' },
        body: JSON.stringify({
          emoji: 'ðŸŽ‰',
        }),
      })

      expect(response1.status).toBe(201)
      expect(response2.status).toBe(201)

      const reaction1 = await response1.json()
      const reaction2 = await response2.json()

      expect(reaction1.userId).toBe(user1.id)
      expect(reaction2.userId).toBe(user2.id)
      expect(reaction1.emoji).toBe('ðŸŽ‰')
      expect(reaction2.emoji).toBe('ðŸŽ‰')
    })

    it('returns 404 for non-existent message', async () => {
      const { chatUser: user, headers } = await createAuthUserWithChatUser('user1', 'user1@test.com')

      const response = await app.request('/messages/00000000-0000-0000-0000-000000000000/reactions', {
        method: 'POST',
        headers: { ...headers, 'Content-Type': 'application/json' },
        body: JSON.stringify({
          emoji: 'ðŸ‘',
        }),
      })

      expect(response.status).toBe(404)
      await expect(response.json()).resolves.toMatchObject({
        message: 'Message not found',
      })
    })
  })

  describe('DELETE /messages/:id/reactions/:emoji', () => {
    it('removes a reaction from a message', async () => {
      const { chatUser: user1, headers: user1Headers } = await createAuthUserWithChatUser('user1', 'user1@test.com')
      const user2 = await createUser('User 2', 'user2')

      const conversation = await createConversation([user1.id, user2.id], user1Headers)
      const message = await sendMessage(conversation.id, user1Headers, 'Test message')

      // Add reaction (authenticated user1 is reacting)
      await app.request(`/messages/${message.id}/reactions`, {
        method: 'POST',
        headers: { ...user1Headers, 'Content-Type': 'application/json' },
        body: JSON.stringify({
          emoji: 'â¤ï¸',
        }),
      })

      // Remove reaction (authenticated user1 is removing their own reaction)
      const response = await app.request(
        `/messages/${message.id}/reactions/${encodeURIComponent('â¤ï¸')}`,
        {
          method: 'DELETE',
          headers: user1Headers,
        }
      )

      expect(response.status).toBe(200)

      const deletedReaction = await response.json()

      // Zod schema validation
      expectValidZodSchema(deleteMessagesIdReactionsEmojiResponse, deletedReaction, 'deleted reaction')

      // Business logic assertions
      expect(deletedReaction.messageId).toBe(message.id)
      expect(deletedReaction.userId).toBe(user1.id) // Authenticated user (user1) removed the reaction
      expect(deletedReaction.emoji).toBe('â¤ï¸')
    })

    it('returns 404 when removing non-existent reaction', async () => {
      const { chatUser: user1, headers: user1Headers } = await createAuthUserWithChatUser('user1', 'user1@test.com')
      const user2 = await createUser('User 2', 'user2')

      const conversation = await createConversation([user1.id, user2.id], user1Headers)
      const message = await sendMessage(conversation.id, user1Headers, 'Test')

      // Try to remove a reaction that was never added
      const response = await app.request(
        `/messages/${message.id}/reactions/${encodeURIComponent('ðŸ‘')}`,
        {
          method: 'DELETE',
          headers: user1Headers,
        }
      )

      expect(response.status).toBe(404)
    })

    it('returns 404 for non-existent message', async () => {
      const { chatUser: user1, headers: user1Headers } = await createAuthUserWithChatUser('user1', 'user1@test.com')

      // Try to remove reaction from non-existent message
      const response = await app.request(
        `/messages/00000000-0000-0000-0000-000000000000/reactions/${encodeURIComponent('ðŸ˜€')}`,
        {
          method: 'DELETE',
          headers: user1Headers,
        }
      )

      expect(response.status).toBe(404)
    })
  })

  describe('GET /messages/:id/reactions', () => {
    it('returns empty array when no reactions', async () => {
      const { chatUser: user1, headers: user1Headers } = await createAuthUserWithChatUser('user1', 'user1@test.com')
      const user2 = await createUser('User 2', 'user2')

      const conversation = await createConversation([user1.id, user2.id], user1Headers)
      const message = await sendMessage(conversation.id, user1Headers, 'Hello!')

      const response = await app.request(`/messages/${message.id}/reactions`, {
        method: 'GET',
        headers: user1Headers,
      })

      expect(response.status).toBe(200)

      const reactions = await response.json()

      // Zod schema validation
      expectValidZodSchema(getMessagesIdReactionsResponse, reactions, 'reactions')

      // Snapshot testing
      expectMatchesSnapshot(reactions, 'GET /messages/:id/reactions - empty array')

      // Business logic assertions
      expect(reactions).toEqual([])
    })

    it('returns all reactions for a message', async () => {
      const { chatUser: user1, headers: user1Headers } = await createAuthUserWithChatUser('user1', 'user1@test.com')
      const { chatUser: user2, headers: user2Headers } = await createAuthUserWithChatUser('user2', 'user2@test.com')
      const user3 = await createUser('User 3', 'user3')

      const conversation = await createConversation([user1.id, user2.id, user3.id], user1Headers)
      const message = await sendMessage(conversation.id, user1Headers, 'Great news!')

      // User 1 reacts with ðŸ‘
      await app.request(`/messages/${message.id}/reactions`, {
        method: 'POST',
        headers: { ...user1Headers, 'Content-Type': 'application/json' },
        body: JSON.stringify({
          emoji: 'ðŸ‘',
        }),
      })

      // User 2 reacts with ðŸŽ‰
      await app.request(`/messages/${message.id}/reactions`, {
        method: 'POST',
        headers: { ...user2Headers, 'Content-Type': 'application/json' },
        body: JSON.stringify({
          emoji: 'ðŸŽ‰',
        }),
      })

      // User 1 also reacts with â¤ï¸
      await app.request(`/messages/${message.id}/reactions`, {
        method: 'POST',
        headers: { ...user1Headers, 'Content-Type': 'application/json' },
        body: JSON.stringify({
          emoji: 'â¤ï¸',
        }),
      })

      const response = await app.request(`/messages/${message.id}/reactions`, {
        method: 'GET',
        headers: user1Headers,
      })

      expect(response.status).toBe(200)

      const reactions = await response.json()

      // Zod schema validation
      expectValidZodSchema(getMessagesIdReactionsResponse, reactions, 'reactions')

      // Snapshot testing
      expectMatchesSnapshot(reactions, 'GET /messages/:id/reactions - multiple reactions')

      // Business logic assertions
      expect(reactions).toHaveLength(3)
      expect(reactions.some((r: any) => r.userId === user1.id && r.emoji === 'ðŸ‘')).toBe(true)
      expect(reactions.some((r: any) => r.userId === user2.id && r.emoji === 'ðŸŽ‰')).toBe(true)
      expect(reactions.some((r: any) => r.userId === user1.id && r.emoji === 'â¤ï¸')).toBe(true)
    })

    it('returns 404 for non-existent message', async () => {
      const { headers } = await createAuthUserWithChatUser('user1', 'user1@test.com')
      const fakeMessageId = '00000000-0000-0000-0000-000000000000'

      const response = await app.request(`/messages/${fakeMessageId}/reactions`, {
        method: 'GET',
        headers,
      })

      expect(response.status).toBe(404)
    })
  })

  describe('POST /messages/:id/bookmarks', () => {
    it('bookmarks a message', async () => {
      const { chatUser: user1, headers: user1Headers } = await createAuthUserWithChatUser('user1', 'user1@test.com')
      const user2 = await createUser('User 2', 'user2')

      const conversation = await createConversation([user1.id, user2.id], user1Headers)
      const message = await sendMessage(conversation.id, user1Headers, 'Important message')

      // Bookmark the message (authenticated user1 is bookmarking)
      const response = await app.request(`/messages/${message.id}/bookmarks`, {
        method: 'POST',
        headers: { ...user1Headers, 'Content-Type': 'application/json' },
        body: JSON.stringify({}),
      })

      expect(response.status).toBe(201)

      const result = await response.json()

      // Zod schema validation
      expectValidZodSchema(postMessagesIdBookmarksResponse, result, 'bookmark response')

      // Snapshot testing - captures complete bookmark response structure
      expectMatchesSnapshot(result, 'POST /messages/:id/bookmarks - bookmark message')

      // Business logic assertions
      expect(result.status).toBe('bookmarked')
      expect(result.bookmark.messageId).toBe(message.id)
      expect(result.bookmark.userId).toBe(user1.id) // Authenticated user (user1) bookmarked the message
    })

    it('allows the same message to be bookmarked by different users', async () => {
      const { chatUser: user1, headers: user1Headers } = await createAuthUserWithChatUser('user1', 'user1@test.com')
      const { chatUser: user2, headers: user2Headers } = await createAuthUserWithChatUser('user2', 'user2@test.com')
      const user3 = await createUser('User 3', 'user3')

      const conversation = await createConversation([user1.id, user2.id, user3.id], user1Headers)
      const message = await sendMessage(conversation.id, user1Headers, 'Shared important info')

      // User 1 bookmarks
      const response1 = await app.request(`/messages/${message.id}/bookmarks`, {
        method: 'POST',
        headers: { ...user1Headers, 'Content-Type': 'application/json' },
        body: JSON.stringify({}),
      })

      // User 2 bookmarks
      const response2 = await app.request(`/messages/${message.id}/bookmarks`, {
        method: 'POST',
        headers: { ...user2Headers, 'Content-Type': 'application/json' },
        body: JSON.stringify({}),
      })

      expect(response1.status).toBe(201)
      expect(response2.status).toBe(201)

      const result1 = await response1.json()
      const result2 = await response2.json()

      expect(result1.bookmark.userId).toBe(user1.id)
      expect(result2.bookmark.userId).toBe(user2.id)
      expect(result1.bookmark.messageId).toBe(message.id)
      expect(result2.bookmark.messageId).toBe(message.id)
    })

    it('returns 404 for non-existent message', async () => {
      const { chatUser: user, headers } = await createAuthUserWithChatUser('user1', 'user1@test.com')

      const response = await app.request('/messages/00000000-0000-0000-0000-000000000000/bookmarks', {
        method: 'POST',
        headers: { ...headers, 'Content-Type': 'application/json' },
        body: JSON.stringify({}),
      })

      expect(response.status).toBe(404)
      await expect(response.json()).resolves.toMatchObject({
        message: 'Message not found',
      })
    })
  })

  describe('DELETE /messages/:id/bookmarks', () => {
    it('removes a bookmark from a message', async () => {
      const { chatUser: user1, headers: user1Headers } = await createAuthUserWithChatUser('user1', 'user1@test.com')
      const user2 = await createUser('User 2', 'user2')

      const conversation = await createConversation([user1.id, user2.id], user1Headers)
      const message = await sendMessage(conversation.id, user1Headers, 'Bookmarked message')

      // Add bookmark (authenticated user1 is bookmarking)
      await app.request(`/messages/${message.id}/bookmarks`, {
        method: 'POST',
        headers: { ...user1Headers, 'Content-Type': 'application/json' },
        body: JSON.stringify({}),
      })

      // Remove bookmark (authenticated user1 is removing their own bookmark)
      const response = await app.request(
        `/messages/${message.id}/bookmarks`,
        {
          method: 'DELETE',
          headers: user1Headers,
        }
      )

      expect(response.status).toBe(200)

      const result = await response.json()

      // Zod schema validation
      expectValidZodSchema(deleteMessagesIdBookmarksResponse, result, 'unbookmark response')

      // Business logic assertion
      expect(result.status).toBe('unbookmarked')
    })

    it('returns 404 for non-existent bookmark', async () => {
      const { chatUser: user1, headers: user1Headers } = await createAuthUserWithChatUser('user1', 'user1@test.com')
      const user2 = await createUser('User 2', 'user2')

      const conversation = await createConversation([user1.id, user2.id], user1Headers)
      const message = await sendMessage(conversation.id, user1Headers, 'Test')

      // Try to remove bookmark that doesn't exist (user1 never bookmarked it)
      const response = await app.request(
        `/messages/${message.id}/bookmarks`,
        {
          method: 'DELETE',
          headers: user1Headers,
        }
      )

      expect(response.status).toBe(404)
    })

    it('returns 404 for non-existent message', async () => {
      const { chatUser: user1, headers: user1Headers } = await createAuthUserWithChatUser('user1', 'user1@test.com')

      // Try to remove bookmark from non-existent message
      const response = await app.request(
        `/messages/00000000-0000-0000-0000-000000000000/bookmarks`,
        {
          method: 'DELETE',
          headers: user1Headers,
        }
      )

      expect(response.status).toBe(404)
    })
  })

  describe('GET /bookmarks', () => {
    it('returns list of bookmarks for authenticated user', async () => {
      const { chatUser: user1, headers: user1Headers } = await createAuthUserWithChatUser('user1', 'user1@test.com')
      const user2 = await createUser('User 2', 'user2')

      const conversation = await createConversation([user1.id, user2.id], user1Headers)
      const message1 = await sendMessage(conversation.id, user1Headers, 'First bookmark')
      const message2 = await sendMessage(conversation.id, user1Headers, 'Second bookmark')

      // Add bookmarks (authenticated user1 is bookmarking)
      await app.request(`/messages/${message1.id}/bookmarks`, {
        method: 'POST',
        headers: { ...user1Headers, 'Content-Type': 'application/json' },
        body: JSON.stringify({}),
      })

      await app.request(`/messages/${message2.id}/bookmarks`, {
        method: 'POST',
        headers: { ...user1Headers, 'Content-Type': 'application/json' },
        body: JSON.stringify({}),
      })

      // Get bookmarks list (authenticated user's bookmarks)
      const response = await app.request('/bookmarks', {
        headers: user1Headers,
      })

      expect(response.status).toBe(200)

      const bookmarks = await response.json()
      expect(Array.isArray(bookmarks)).toBe(true)
      expect(bookmarks.length).toBeGreaterThanOrEqual(2)

      // Zod schema validation for all bookmarks in the array
      expectValidZodSchemaArray(getUsersUserIdBookmarksResponseItem, bookmarks, 'bookmarks')
    })

    it('returns empty array when user has no bookmarks', async () => {
      const { chatUser: user, headers } = await createAuthUserWithChatUser('user1', 'user1@test.com')

      const response = await app.request('/bookmarks', {
        headers,
      })

      expect(response.status).toBe(200)

      const bookmarks = await response.json()
      expect(Array.isArray(bookmarks)).toBe(true)
      expect(bookmarks.length).toBe(0)
    })
  })
})
